package plugin.decimal;

import com.cloudera.sqoop.SqoopOptions;
import com.cloudera.sqoop.manager.ConnManager;
import org.apache.avro.LogicalType;
import org.apache.avro.Schema;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.sqoop.avro.AvroUtil;
import org.apache.sqoop.config.ConfigurationConstants;
import org.apache.sqoop.orm.AvroSchemaGenerator;
import org.apache.sqoop.orm.ClassWriter;
import org.apache.sqoop.orm.CompilationManager;
import org.apache.sqoop.orm.TableClassName;
import org.codehaus.jackson.node.NullNode;

import java.io.IOException;
import java.sql.Types;
import java.util.*;


/**
 * TODO
 *
 * @author hsh
 * @create 2020年10月19日
 */
public class AvroSchemaGeneratorOverride{

//    private SqoopOptions options;
//    private ConnManager connManager;
//    private String tableName;
//
//    public AvroSchemaGeneratorOverride(SqoopOptions opts, ConnManager connMgr, String table) {
//       super(opts,connMgr,table);
//       this.options = opts;
//       this.connManager = connMgr;
//       this.tableName = table;
//    }
//
//
    public Schema toAvroSchema(int sqlType, String columnName, Integer precision, Integer scale) {
        List<Schema> childSchemas = new ArrayList();
        childSchemas.add(Schema.create(Schema.Type.NULL));
        if (this.options.getConf().getBoolean("sqoop.avro.logical_types.decimal.enable", false) || isLogicalType(sqlType)) {
            if (precision > 18) {
                childSchemas.add(this.toAvroLogicalType(columnName, sqlType, precision, scale).addToSchema(Schema.create(Schema.Type.BYTES)));
            }
            else {
                childSchemas.add(this.toAvroLogicalType(columnName, sqlType, precision, scale).addToSchema(Schema.createFixed(columnName, (String)null, (String)null, AvroSchemaGeneratorOverride.PRECISION_TO_BYTE_COUNT[precision - 1])));
            }
        } else {
            childSchemas.add(Schema.create(this.toAvroType(columnName, sqlType)));
        }

        return Schema.createUnion(childSchemas);
    }
//
//
//
//    private Schema.Type toAvroType(String columnName, int sqlType) {
//        Properties mapping = this.options.getMapColumnJava();
//        if (mapping.containsKey(columnName)) {
//            String type = mapping.getProperty(columnName);
//            if (LOG.isDebugEnabled()) {
//                LOG.info("Overriding type of column " + columnName + " to " + type);
//            }
//
//            if (type.equalsIgnoreCase("INTEGER")) {
//                return Schema.Type.INT;
//            } else if (type.equalsIgnoreCase("LONG")) {
//                return Schema.Type.LONG;
//            } else if (type.equalsIgnoreCase("BOOLEAN")) {
//                return Schema.Type.BOOLEAN;
//            } else if (type.equalsIgnoreCase("FLOAT")) {
//                return Schema.Type.FLOAT;
//            } else if (type.equalsIgnoreCase("DOUBLE")) {
//                return Schema.Type.DOUBLE;
//            } else if (type.equalsIgnoreCase("STRING")) {
//                return Schema.Type.STRING;
//            } else if (type.equalsIgnoreCase("BYTES")) {
//                return Schema.Type.BYTES;
//            } else {
//                throw new IllegalArgumentException("Cannot convert to AVRO type " + type);
//            }
//        } else {
//            return this.connManager.toAvroType(this.tableName, columnName, sqlType);
//        }
//    }
//
//    private LogicalType toAvroLogicalType(String columnName, int sqlType, Integer precision, Integer scale) {
//        return this.connManager.toAvroLogicalType(this.tableName, columnName, sqlType, precision, scale);
//    }
//
//    private static boolean isLogicalType(int sqlType) {
//        switch(sqlType) {
//            case 2:
//            case 3:
//                return true;
//            default:
//                return false;
//        }
//    }






    public static final Log LOG = LogFactory.getLog(AvroSchemaGenerator.class.getName());
    public static final int MAX_PRECISION = 38;
    public static final int[] PRECISION_TO_BYTE_COUNT = new int[38];
    private final SqoopOptions options;
    private final ConnManager connManager;
    private final String tableName;
    private final String DEFAULT_SCHEMA_NAME = "AutoGeneratedSchema";

    public AvroSchemaGeneratorOverride(SqoopOptions opts, ConnManager connMgr, String table) {
        this.options = opts;
        this.connManager = connMgr;
        this.tableName = table;
    }

    public Schema generate() throws IOException {
        return this.generate((String)null);
    }

    protected Map<String, List<Integer>> getColumnInfo() throws IOException {
        return this.options.getCall() == null ? this.connManager.getColumnInfo(this.tableName, this.options.getSqlQuery()) : this.connManager.getColumnInfoForProcedure(this.options.getCall());
    }

    protected String[] getColumnNames(Map<String, Integer> columnTypes) {
        String[] colNames = this.options.getColumns();
        if (null == colNames) {
            if (null != this.tableName) {
                colNames = this.connManager.getColumnNames(this.tableName);
            } else if (this.options.getCall() != null) {
                colNames = this.connManager.getColumnNamesForProcedure(this.options.getCall());
            } else {
                colNames = this.connManager.getColumnNamesForQuery(this.options.getSqlQuery());
            }
        } else {
            String[] fixedColNames = new String[colNames.length];

            for(int i = 0; i < colNames.length; ++i) {
                String userColName = colNames[i];
                int len = userColName.length();
                if (len > 2 && userColName.charAt(0) == '"' && userColName.charAt(len - 1) == '"') {
                    userColName = userColName.substring(1, len - 1);
                }

                fixedColNames[i] = userColName;
                Iterator var7 = columnTypes.entrySet().iterator();

                while(var7.hasNext()) {
                    Map.Entry<String, Integer> typeEntry = (Map.Entry)var7.next();
                    String typeColName = (String)typeEntry.getKey();
                    if (typeColName.equalsIgnoreCase(userColName) && !typeColName.equals(userColName)) {
                        columnTypes.put(userColName, typeEntry.getValue());
                        break;
                    }
                }
            }

            colNames = fixedColNames;
        }

        return colNames;
    }

    protected Map<String, Integer> getColumnTypes() throws IOException {
        return this.options.getCall() == null ? this.connManager.getColumnTypes(this.tableName, this.options.getSqlQuery()) : this.connManager.getColumnTypesForProcedure(this.options.getCall());
    }

    public Schema generate(String schemaNameOverride) throws IOException {
        ClassWriter classWriter = new ClassWriter(this.options, this.connManager, this.tableName, (CompilationManager)null);
        Map<String, List<Integer>> columnInfo = getColumnInfo();
        Map<String, Integer> columnTypes = getColumnTypes();
        String[] columnNames = getColumnNames(columnTypes);
        List<Schema.Field> fields = new ArrayList();
        String[] var7 = columnNames;
        int var8 = columnNames.length;

        String avroName;
        String avroNamespace;
        for(int var9 = 0; var9 < var8; ++var9) {
            avroName = var7[var9];
            avroNamespace = AvroUtil.toAvroIdentifier(ClassWriter.toJavaIdentifier(avroName));
            List<Integer> columnInfoList = (List)columnInfo.get(avroName);
            int sqlType = (Integer)columnInfoList.get(0);
            Integer precision = (Integer)columnInfoList.get(1);
            Integer scale = (Integer)columnInfoList.get(2);
            Schema avroSchema = this.toAvroSchema(sqlType, avroName, precision, scale);
            Schema.Field field = new Schema.Field(avroNamespace, avroSchema, (String)null, NullNode.getInstance());
            field.addProp("columnName", avroName);
            field.addProp("sqlType", Integer.toString(sqlType));
            fields.add(field);
        }

        TableClassName tableClassName = new TableClassName(this.options);
        String shortClassName = this.tableName == null ? "AutoGeneratedSchema" : tableClassName.getShortClassForTable(this.tableName);
        String avroTableName = this.tableName == null ? "QueryResult" : this.tableName;
        avroName = schemaNameOverride != null ? schemaNameOverride : (shortClassName == null ? avroTableName : shortClassName);
        avroNamespace = tableClassName.getPackageForTable();
        String doc = "Sqoop import of " + avroTableName;
        Schema schema = Schema.createRecord(avroName, doc, avroNamespace, false);
        schema.setFields(fields);
        schema.addProp("tableName", avroTableName);
        return schema;
    }

//    public Schema toAvroSchema(int sqlType, String columnName, Integer precision, Integer scale) {
//        List<Schema> childSchemas = new ArrayList();
//        childSchemas.add(Schema.create(Schema.Type.NULL));
//        if (this.options.getConf().getBoolean("sqoop.avro.logical_types.decimal.enable", false) && isLogicalType(sqlType)) {
//            childSchemas.add(this.toAvroLogicalType(columnName, sqlType, precision, scale).addToSchema(Schema.create(Schema.Type.BYTES)));
//        } else {
//            childSchemas.add(Schema.create(this.toAvroType(columnName, sqlType)));
//        }
//
//        return Schema.createUnion(childSchemas);
//    }

    public Schema toAvroSchema(int sqlType) {
        return this.toAvroSchema(sqlType, (String)null, (Integer)null, (Integer)null);
    }

    private Schema.Type toAvroType(String columnName, int sqlType) {
        Properties mapping = this.options.getMapColumnJava();
        if (mapping.containsKey(columnName)) {
            String type = mapping.getProperty(columnName);
            if (LOG.isDebugEnabled()) {
                LOG.info("Overriding type of column " + columnName + " to " + type);
            }

            if (type.equalsIgnoreCase("INTEGER")) {
                return Schema.Type.INT;
            } else if (type.equalsIgnoreCase("LONG")) {
                return Schema.Type.LONG;
            } else if (type.equalsIgnoreCase("BOOLEAN")) {
                return Schema.Type.BOOLEAN;
            } else if (type.equalsIgnoreCase("FLOAT")) {
                return Schema.Type.FLOAT;
            } else if (type.equalsIgnoreCase("DOUBLE")) {
                return Schema.Type.DOUBLE;
            } else if (type.equalsIgnoreCase("STRING")) {
                return Schema.Type.STRING;
            } else if (type.equalsIgnoreCase("BYTES")) {
                return Schema.Type.BYTES;
            } else {
                throw new IllegalArgumentException("Cannot convert to AVRO type " + type);
            }
        } else {
            return this.connManager.toAvroType(this.tableName, columnName, sqlType);
        }
    }

    private LogicalType toAvroLogicalType(String columnName, int sqlType, Integer precision, Integer scale) {
        return this.connManager.toAvroLogicalType(this.tableName, columnName, sqlType, precision, scale);
    }

    private static boolean isLogicalType(int sqlType) {
        switch(sqlType) {
            case 2:
            case 3:
                return true;
            default:
                return false;
        }
    }

    static {
        for(int prec = 1; prec <= 38; ++prec) {
            PRECISION_TO_BYTE_COUNT[prec - 1] = (int)Math.ceil((Math.log(Math.pow(10.0D, (double)prec) - 1.0D) / Math.log(2.0D) + 1.0D) / 8.0D);
        }

    }

}